#!/usr/bin/env python
# -*- coding: utf-8 -*-

from thesis_detect.msg import CrossingDataArray
from enum import Enum
from std_msgs.msg import UInt8
from nav_msgs.msg import Odometry
from tf.transformations import euler_from_quaternion
from geometry_msgs.msg import Point, Twist
from math import atan2
import random
import rospy
from thesis_detect.math_util import *
import numpy as np


class ControlCrossing():
    def __init__(self):
        self.init()
        self.desired_theta = 0.0
        self.pub_crossing_step = rospy.Publisher('/detect/crossing_stamped', UInt8, queue_size=1)

        self.sub_odom = rospy.Subscriber("/odom", Odometry, self.cb_odom, queue_size=1)
        self.pub_navigation = rospy.Publisher('cmd_vel', Twist, queue_size=1)

        self.CrossingSteps = Enum('CrossingSteps', 'idle drive_to_start drive_to_end finished')
        self.Modes = Enum("Modes", 'always_right always_left always_straight random')

        self.mode = self.Modes.always_left.value
        self.VEL = 0.05

        self.current_x = 0.0
        self.current_y = 0.0
        self.current_theta = 0.0

    def init(self):
        self.sub_crossing_data = rospy.Subscriber('/detect/crossing/data', CrossingDataArray, self.cb_get_data,
                                                  queue_size=1)
        self.data = None
        self.relevant_msg = None
        self.direction = None

    def cb_odom(self, msg):
        self.current_x = msg.pose.pose.position.x
        self.current_y = msg.pose.pose.position.y

        rot_q = msg.pose.pose.orientation
        _, _, self.current_theta = euler_from_quaternion([rot_q.x, rot_q.y, rot_q.z, rot_q.w])

    def cb_get_data(self, message):
        self.data = message.crossingData
        if self.data:
            msg_pub_crossing_return = UInt8()
            msg_pub_crossing_return.data = self.CrossingSteps.drive_to_start.value
            self.pub_crossing_step.publish(msg_pub_crossing_return)

            self.sub_crossing_data.unregister()
            self.control_crossing()

    def control_crossing(self):
        directions = ["right", "left", "straight"]
        if self.mode == self.Modes.always_right.value:
            self.direction = directions[0]
        elif self.mode == self.Modes.always_left.value:
            self.direction = directions[1]
        elif self.mode == self.Modes.always_straight.value:
            self.direction = directions[2]
        else:
            self.direction = random.choice(directions)

        rospy.loginfo("Taking direction %s" % self.direction)
        for msg in self.data:
            if msg.direction == self.direction and msg.allowed:
                self.relevant_msg = msg
        if self.relevant_msg is None:
            self.relevant_msg = self.data[0]

        rospy.loginfo("Orienting on crossing %s" % self.relevant_msg)

        self.drive_to_start()

        self.check_traffic()

        if self.direction is not "straight" and self.relevant_msg.allowed:
            self.drive_to_target()

        msg_pub_crossing_return = UInt8()
        msg_pub_crossing_return.data = self.CrossingSteps.finished.value
        self.pub_crossing_step.publish(msg_pub_crossing_return)
        self.init()

    def main(self):
        rospy.spin()

    def drive_to_start(self):
        rospy.loginfo(self.relevant_msg)
        rospy.loginfo("driving to start point")
        goal = np.array([self.relevant_msg.start_x, self.relevant_msg.start_y])
        self.drive_to_point_in_angle(goal, self.relevant_msg.angle_start)
        rospy.loginfo("start point reached")

    def drive_to_point_in_angle(self, goal, angle):
        nearby = False
        r = rospy.Rate(10)
        self.desired_theta = angle + self.current_theta
        linear_distance = get_distance_between_vectors(goal, np.array([self.current_x, self.current_y]))
        angular_distance = angle
        previous_distance = linear_distance

        print(angle)
        print(self.desired_theta)
        print(self.current_theta)
        while not nearby:
            twist_msg = Twist()
            time_units = linear_distance / self.VEL
            angular_velocity = angular_distance / time_units

            if abs(self.desired_theta - self.current_theta) < 0.05:
                remaining_distance = get_distance_between_vectors(goal, np.array([self.current_x, self.current_y]))
                angular_velocity = (self.desired_theta - self.current_theta) / (remaining_distance / self.VEL)

            twist_msg.linear.x = self.VEL
            twist_msg.angular.z = angular_velocity

            self.pub_navigation.publish(twist_msg)
            r.sleep()

            distance = get_distance_between_vectors(goal, np.array([self.current_x, self.current_y]))
            if distance > previous_distance:
                nearby = True
                continue
            previous_distance = distance

            # Failsafe
            if get_distance_between_vectors(goal, np.array([self.current_x, self.current_y])) > linear_distance + 1:
                nearby = True
        twist_msg = Twist()
        twist_msg.linear.x = 0
        twist_msg.angular.z = 0
        self.pub_navigation.publish(twist_msg)

    def check_traffic(self):
        rospy.loginfo("checking for traffic (not yet implemented)")
        pass

    def drive_to_target(self):
        rospy.loginfo("driving to target point")
        angle_target = self.relevant_msg.angle_target
        if self.direction == "right":
            angle_target = -angle_target
        goal = np.array([self.relevant_msg.target_x, self.relevant_msg.target_y])
        self.drive_to_point_in_angle(goal, angle_target)
        rospy.loginfo("target point reached")


if __name__ == '__main__':
    rospy.init_node('control_crossing')
    node = ControlCrossing()
    node.main()
